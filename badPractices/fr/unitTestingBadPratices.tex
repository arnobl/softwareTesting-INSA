\documentclass{article}

% To compile with xelatex only

\usepackage{color}
\usepackage[english,french]{babel}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{listings}
\usepackage{url}
\usepackage{fontspec}
\usepackage{mathpazo}
\linespread{1.05}
\newfontfamily\DejaSans{DejaVu Sans}
\setmainfont
     [ BoldFont       = texgyrepagella-bold.otf ,
       ItalicFont     = texgyrepagella-italic.otf ,
       BoldItalicFont = texgyrepagella-bolditalic.otf ]
     {texgyrepagella-regular.otf}


\geometry{top=4cm, bottom=2cm, left=2.5cm, right=2.5cm}

\clubpenalty=10000
\widowpenalty=10000
\hyphenpenalty=5000
\tolerance=1000

\newcommand{\bad}{\vspace*{-0.15cm}\noindent{\huge \fontspec{DejaVu Sans} üò±}}
\newcommand{\Bad}{\vspace*{-0.15cm}\noindent{\huge \fontspec{DejaVu Sans} ‚òπ\\üò±}}
\newcommand{\Good}{\vspace*{-0.15cm}\noindent{\huge \fontspec{DejaVu Sans} üòÉ\\üòç} }
\newcommand{\good}{\vspace*{-0.15cm}\noindent{\huge \fontspec{DejaVu Sans} üòÉ} }

\lstdefinelanguage{MyJava}{
  frame=single,
  escapechar=|, 
  numbersep=5pt, 
  numbers=none, 
  language=java, 
  showstringspaces=false,
  tabsize=2,
  basicstyle=\DejaSans\small
}


\title{\vspace*{-3cm}{\huge Mauvaises pratiques dans l'√©criture de tests}}

\author{Arnaud Blouin}
\date{}


\begin{document}

\maketitle

Les exemples de ce document sont √©crits en JUnit 5 et Mockito mais les mauvaises pratiques qu'ils illustrent s'appliquent √† toutes les librairies de test.


\section*{Assertions}

Parmi les mauvaises pratiques de test unitaire les plus courantes, une r√©currente consiste √† utiliser \emph{assertTrue} et \emph{assertFalse} √† tout va.

\medskip
\begin{minipage}{0.07\textwidth}
\Bad
\end{minipage}%
\begin{minipage}{0.9\textwidth}
\begin{lstlisting}[language=MyJava]
@Test public void testSetStr() {
  obj.setStr("foo");
  assertTrue(pt.getStr().equals("foo"));
}
@Test public void testSetA() {
  obj.setA(a);
  assertTrue(obj.getA()==a);
}
\end{lstlisting}   
\end{minipage}

Ce cas simple n'est pas tr√®s grave est soit mais il existe des assertions d√©di√©es √† la comparaison d'objets. 
La bonne pratique est donc d'utiliser ces assertions :

\medskip
\begin{minipage}{0.07\textwidth}
\Good
\end{minipage}%
\begin{minipage}{0.9\textwidth}
\begin{lstlisting}[language=MyJava]
@Test public void testSetStr() {
  obj.setStr("foo");
  assertEquals("foo", pt.getStr()); // La valeur attendue est √† gauche en JUnit
}
@Test public void testSetA() {
  obj.setA(a);
  assertSame(a, obj.getA()); // La valeur observ√©e est √† droite
}
\end{lstlisting}   
\end{minipage}

Attention au test de valeurs flottantes :
la comparaison de valeurs flottantes (\emph{double} en Java, mais pas de probl√®me avec \emph{float}) n'est pas exacte.
Il faut utiliser un delta de tol√©rance.
Donc √† la place du code suivant :

\medskip
\begin{minipage}{0.07\textwidth}
\Bad
\end{minipage}%
\begin{minipage}{0.9\textwidth}
\begin{lstlisting}[language=MyJava]
@Test public void testSetX() {
  pt.setX(10.0);
  assertEquals(10.0, pt.getX());
}
\end{lstlisting}   
\end{minipage}

\noindent il faut √©crire :

\medskip
\begin{minipage}{0.07\textwidth}
\Good
\end{minipage}%
\begin{minipage}{0.9\textwidth}
\begin{lstlisting}[language=MyJava]
@Test public void testSetX() {
  pt.setX(10.0);
  assertTrue(10.0, pt.getX(), 0.00001); // Troisi√®me argument : delta tol√©rance
}
\end{lstlisting}
\end{minipage}


% \noindent Pour faire √©chouer un test (√† utiliser tr√®s rarement), ne pas √©crire :
%
% \medskip
% \begin{minipage}{0.07\textwidth}
% \bad
% \end{minipage}%
% \begin{minipage}{0.9\textwidth}
% \begin{lstlisting}[language=MyJava]
% assertEquals(true, false);
% \end{lstlisting}
% \end{minipage}
%
% \noindent mais:
%
% \medskip
% \begin{minipage}{0.07\textwidth}
% \good
% \end{minipage}%
% \begin{minipage}{0.9\textwidth}
% \begin{lstlisting}[language=MyJava]
% fail();
% \end{lstlisting}
% \end{minipage}

Il n'existe pas, et √† raison, d'assertion "\emph{success}" :
si aucune assertion n'√©choue ou si aucune exception n'est lev√©e, alors le test passe automatiquement.
Vous ne devez donc pas √©crire quelque chose du style :

\medskip
\begin{minipage}{0.07\textwidth}
\bad
\end{minipage}%
\begin{minipage}{0.9\textwidth}
\begin{lstlisting}[language=MyJava]
assertTrue(true);
\end{lstlisting}
\end{minipage}

\noindent ou :

\medskip
\begin{minipage}{0.07\textwidth}
\bad
\end{minipage}%
\begin{minipage}{0.9\textwidth}
\begin{lstlisting}[language=MyJava]
assertEquals(true, true);
\end{lstlisting}
\end{minipage}

Il existe beaucoup d'assertions, cf : 
\url{http://junit.sourceforge.net/javadoc/org/junit/Assert.html}.
Ne pas utiliser la bonne assertion est une mauvaise pratique.
Par exemple :
% There exists plenty of assertion methods.
% See: \url{http://junit.sourceforge.net/javadoc/org/junit/Assert.html}.
% Bad testing practices consist in not using the correct assertion method.
% For example:

\medskip
\begin{minipage}{0.07\textwidth}
\bad
\end{minipage}%
\begin{minipage}{0.9\textwidth}
\begin{lstlisting}[language=MyJava]
assertTrue(a!=b);
\end{lstlisting}
\end{minipage}

\noindent √Ä la place :

\medskip
\begin{minipage}{0.07\textwidth}
\good
\end{minipage}%
\begin{minipage}{0.9\textwidth}
\begin{lstlisting}[language=MyJava]
assertNotEquals(a, b);
\end{lstlisting}
\end{minipage}

\noindent Un autre exemple, l'assertion :

\medskip
\begin{minipage}{0.07\textwidth}
\bad
\end{minipage}%
\begin{minipage}{0.9\textwidth}
\begin{lstlisting}[language=MyJava]
assertTrue(a!=null);
\end{lstlisting}
\end{minipage}

\noindent devrait √™tre √©crite :

\medskip
\begin{minipage}{0.07\textwidth}
\good
\end{minipage}%
\begin{minipage}{0.9\textwidth}
\begin{lstlisting}[language=MyJava]
assertNotNull(a);
\end{lstlisting}
\end{minipage}

Les assertions \emph{assertTrue} et \emph{assertFalse} soit utilis√©es pour tester des expressions bool√©ennes. 
L'utilisation d'op√©rateurs √† l'int√©rieur d'une expression d'une assertion (exemple: \texttt{assertTrue(a==b)}) est une mauvaise pratique : vous n'utilisez pas la bonne assertion.


Autres mauvaises pratiques : 
\textbf{mauvaise utilisation du \emph{try / catch} dans un test unitaire qui peut lever des exceptions}.


\medskip
\begin{minipage}{0.07\textwidth}
\Bad
\end{minipage}%
\begin{minipage}{0.9\textwidth}
\begin{lstlisting}[language=MyJava]
@Test
public void testHorizontalSymmetryException() {
  try{
    pt.horizontalSymmetry(null);
    fail();
  }catch(IllegalArgumentException e) {
  // OK
  }
}
\end{lstlisting}
\end{minipage}


Si le test ci¬≠-dessus est correct, JUnit fournit une fonctionnalit√© pour √©viter cette
lourdeur syntaxique : le param√®tre \emph{excepted} de l'annotation \emph{@Test} :

\medskip
\begin{minipage}{0.07\textwidth}
\Good
\end{minipage}%
\begin{minipage}{0.9\textwidth}
\begin{lstlisting}[language=MyJava]
@Test
public void testHorizontalSymmetryException() {
  assertThrows(IllegalArgumentException.class, ()-> pt.horizontalSymmetry(null));
}
\end{lstlisting}
\end{minipage}

\noindent Autre mauvaise pratique concernant les exceptions :

\medskip
\begin{minipage}{0.07\textwidth}
\Bad
\end{minipage}%
\begin{minipage}{0.9\textwidth}
\begin{lstlisting}[language=MyJava]
@Test
public void testHorizontalSymmetry() {
  try{
    pt.horizontalSymmetry(new Point(1,2));
  }catch(IllegalArgumentException e) {
    fail();
  }
}
\end{lstlisting}
\end{minipage}

Le \emph{try / catch} du test ci¬≠-dessus est inutile. Il suffit de d√©clarer l'exception au niveau
du prototype du test. Ainsi, si une exception est lev√©e le test JUnit sera marqu√© comme ayant √©chou√©.

\medskip
\begin{minipage}{0.07\textwidth}
\Good
\end{minipage}%
\begin{minipage}{0.9\textwidth}
\begin{lstlisting}[language=MyJava]
@Test
public void testHorizontalSymmetry() throws IllegalArgumentException {
  pt.horizontalSymmetry(new Point(1,2));
}
\end{lstlisting}
\end{minipage}


Il est √©galement inutile de v√©rifier l'instanciation d'un objet. Ici, \texttt{p} est forcement non nul.
Le test suivant peut donc est supprim√© :

\medskip
\begin{minipage}{0.07\textwidth}
\Bad
\end{minipage}%
\begin{minipage}{0.9\textwidth}
\begin{lstlisting}[language=MyJava]
@Test
public void testPointNotNullWhenCreated() throws IllegalArgumentException {
  pt = new Point();
  assertNotNull(p);
}
\end{lstlisting}
\end{minipage}


\section*{Test fixture}

Au niveau de la classe de tests, une mauvaise pratique consiste √† avoir du code dupliqu√© dans chaque test :

\medskip
\begin{minipage}{0.07\textwidth}
\Bad
\end{minipage}%
\begin{minipage}{0.9\textwidth}
\begin{lstlisting}[language=MyJava]
public class TestPoint {
   @Test
   public void testHorizontalSymmetry() throws IllegalArgumentException {
     Point pt = new Point();
     pt.horizontalSymmetry(new Point(1,2));
   }
   @Test public void testSetGetX() {
     Point pt = new Point();
     pt.setX(10.0);
     assertEquals(10.0, pt.getX(), 0.001);
   }
   @Test public void testSetGetY() {
     Point pt = new Point();
     pt.setY(10.0);
     assertEquals(10.0, pt.getY(), 0.001);
   }
}

\end{lstlisting}
\end{minipage}

Dans le code ci-dessus, la d√©claration et l'initialisation d'un objet est dupliqu√©e dans chaque test.
Dans ce cas il faut utiliser la m√©thode "\emph{@BeforeEach}" comme le montre le code suivant :

\medskip
\begin{minipage}{0.07\textwidth}
\Good
\end{minipage}%
\begin{minipage}{0.9\textwidth}
\begin{lstlisting}[language=MyJava]
public class TestPoint {
   Point pt;
   
   @BeforeEach
   public void setUp() {
     pt = new Point();
   }
   @Test
   public void testHorizontalSymmetry() throws IllegalArgumentException {
     pt.horizontalSymmetry(new Point(1,2));
   }
   @Test public void testSetGetX() {
     pt.setX(10.0);
     assertEquals(10.0, pt.getX(), 0.001);
   }
   @Test public void testSetGetY() {
     pt.setY(10.0);
     assertEquals(10.0, pt.getY(), 0.001);
   }
}

\end{lstlisting}
\end{minipage}


\noindent Concernant la m√©thode \emph{@BeforeEach}, attention √† ne pas √©crire :

\medskip
\begin{minipage}{0.07\textwidth}
\Bad
\end{minipage}%
\begin{minipage}{0.9\textwidth}
\begin{lstlisting}[language=MyJava]
@BeforeEach
public void setUp() {
  Point pt = new Point();
}
\end{lstlisting}
\end{minipage}

La variable \emph{pt} est dans ce cas local et donc pas accessible pour les tests (exemple vu de nombreuses fois dans les copies...).
Il ne faut √©galement pas √©crire :

\medskip
\begin{minipage}{0.07\textwidth}
\Bad
\end{minipage}%
\begin{minipage}{0.9\textwidth}
\begin{lstlisting}[language=MyJava]
public class TestPoint {
   Point pt = new Point();

   @Test
   public void testHorizontalSymmetry() throws IllegalArgumentException {
     pt.horizontalSymmetry(new Point(1,2));
   }
   @Test public void testSetGetX() {
     pt.setX(10.0);
     assertEquals(10.0, pt.getX(), 0.001);
   }
   @Test public void testSetGetY() {
     pt.setY(10.0);
     assertEquals(10.0, pt.getY(), 0.001);
   }
}
\end{lstlisting}
\end{minipage}

En effet, cela peut √©ventuellement fonctionner mais il faut laisser le travail de l'initialisation des tests √† JUnit via la m√©thode \emph{@BeforeEach}.

\newpage

\section*{Structure des tests}


Autre mauvaise pratique plus compliqu√©e, \textbf{√©crire plusieurs tests dans une unique m√©thode de test} :


\medskip
\begin{minipage}{0.07\textwidth}
\Bad
\end{minipage}%
\begin{minipage}{0.9\textwidth}
\begin{lstlisting}[language=MyJava]
@Test public void testSetGetXY() {
  pt.setX(10.0);
  assertEquals(10.0, pt.getX(), 0.001);
  pt.setY(10.0);
  assertEquals(10.0, pt.getY(), 0.001);
}
\end{lstlisting}
\end{minipage}

\noindent Il faut ici √©crire deux tests unitaires s√©par√©s :

\medskip
\begin{minipage}{0.07\textwidth}
\Good
\end{minipage}%
\begin{minipage}{0.9\textwidth}
\begin{lstlisting}[language=MyJava]
@Test public void testSetGetX() {
  pt.setX(10.0);
  assertEquals(10.0, pt.getX(), 0.001);
}
@Test public void testSetGetY() {
  pt.setY(10.0);
  assertEquals(10.0, pt.getY(), 0.001);
}
\end{lstlisting}
\end{minipage}

L'avantage serait d'am√©liorer la lecture des tests et surtout de faciliter le d√©bogage : 
dans le cas du mauvais exemple, si  l'assertion sur \emph{setX} ne passe pas, le test sur \emph{setY} n'est pas ex√©cut√©, ce qui n'est pas coh√©rent.
Il en est de m√™me avec l'exemple suivant :

\medskip
\begin{minipage}{0.07\textwidth}
\Bad
\end{minipage}%
\begin{minipage}{0.9\textwidth}
\begin{lstlisting}[language=MyJava]
@Test public void testSetGetValue() {
  pt.setValue(10.0);
  assertEquals(10.0, pt.getValue(), 0.001);
  pt.setValue(-1.0); // value cannot be negative
  assertEquals(10.0, pt.getValue(), 0.001);
}
\end{lstlisting}
\end{minipage}

Deux tests sont pr√©sents dans le code ci-dessus :
le test nominal (bon fonctionnement) ;
le test du cas d'erreur de valeur n√©gative (dans l'exemple \emph{setValue} ne fait rien si la valeur est n√©gative).
Il faut s√©parer ces deux tests :

\medskip
\begin{minipage}{0.07\textwidth}
\Good
\end{minipage}%
\begin{minipage}{0.9\textwidth}
\begin{lstlisting}[language=MyJava]
@Test public void testSetGetValueOK() {
  pt.setValue(10.0);
  assertEquals(10.0, pt.getValue(), 0.001);
}
@Test public void testSetGetValueKONegValue() {
  pt.setValue(10.0);
  pt.setValue(-1.0); // value cannot be negative
  assertEquals(10.0, pt.getValue(), 0.001);
}
\end{lstlisting}
\end{minipage}

\newpage

\section*{Mock}

Concernant les mocks. Il n'y a aucun int√©r√™t √† simuler l'objet que l'on teste.
Le but des mocks est de casser des d√©pendances √† l'aide de marionnettes (les mocks donc) que vous contr√¥lez.
Le code suivant n'a donc pas de sens :

\medskip
\begin{minipage}{0.07\textwidth}
\Bad
\end{minipage}%
\begin{minipage}{0.9\textwidth}
\begin{lstlisting}[language=MyJava]
public class TestPoint {
   Point pt;

   @BeforeEach
   public void setUp() {
     pt = Mockito.mock(Point.class);
     Mockito.when(pt.getX()).thenReturn(10.0);
   }
   @Test public void testSetGetX() {
     assertEquals(10.0, pt.getX(), 0.001);
   }
}
\end{lstlisting}
\end{minipage}

Autre erreur, mois dramatique que la pr√©c√©dente :
cr√©er une classe pour pouvoir mocker une interface.
Cela n'est pas n√©cessaire car le mocking fonctionne √©galement avec une interface sans impl√©mentation (c'est un de ses buts).

\medskip
\begin{minipage}{0.07\textwidth}
\Bad
\end{minipage}%
\begin{minipage}{0.9\textwidth}
\begin{lstlisting}[language=MyJava]
interface Vector {
   double getTx();
}

public class TestPoint {
   Point pt;
   VectorImpl v;

   static class VectorImpl implements Vector {
      public double getTx() { return 0; }
   }

   @BeforeEach
   public void setUp() {
     v = Mockito.mock(VectorImpl.class);
     Mockito.when(v.getTx()).thenReturn(10.0);
     pt = new Point(v);
   }
}
\end{lstlisting}
\end{minipage}

\newpage

Il faut donc simplifier le code pr√©c√©dent pour obtenir le code suivant.
√Ä noter que la classe \texttt{VectorImpl} est ce que l'on appelle un \emph{stub} (une fausse classe cod√©e par le testeur) et peut √™tre remplac√©e
par un mock : moins verbeux, plus flexible.

\medskip
\begin{minipage}{0.07\textwidth}
\Good
\end{minipage}%
\begin{minipage}{0.9\textwidth}
\begin{lstlisting}[language=MyJava]
interface Vector {
   double getTx();
}

public class TestPoint {
   Point pt;
   Vector v;
   
   @BeforeEach
   public void setUp() {
     v = Mockito.mock(Vector.class);
     // M√™me s'il s'agit d'une interface,
     // il faut √©crire Vector.class et non Vector.interface
     Mockito.when(v.getTx()).thenReturn(10.0);
     pt = new Point(v);
   }
}
\end{lstlisting}
\end{minipage}


\end{document}
